package pm.axe.users;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.RandomStringUtils;
import org.apache.commons.lang3.StringUtils;
import org.springframework.stereotype.Component;
import org.springframework.transaction.CannotCreateTransactionException;
import pm.axe.Axe;
import pm.axe.result.OperationResult;
import pm.axe.services.user.UserService;

/**
 * Class that generates Usernames.
 */
@Slf4j
@RequiredArgsConstructor
@Component
public class UsernameGenerator {
    private static final String TAG = "[" + UsernameGenerator.class.getSimpleName() + "]";
    private static final int MAX_ROUNDS = 5;

    public static final String USER_PREFIX = "user";
    public static final int USERNAME_RANDOM_PART_LEN = 6;

    private final UserService userService;

    /**
     * Checks if username is generated by this generator.
     *
     * @param username non-empty string with username to check.
     * @return true if username is generated to this generator, false - if not.
     */
    public static boolean isGenerated(final String username) {
        return StringUtils.startsWith(username, USER_PREFIX);
    }

    /**
     * Generates new username. This method guarantees that username is unique.
     *
     * @return {@link OperationResult} with username {@link String} in payload or {@link OperationResult} with error.
     */
    public OperationResult generateRandom() {
        try {
            String generatedUsername;
            boolean isUsernameAlreadyExist;
            do {
                generatedUsername = generateNew();
                isUsernameAlreadyExist = userService.isUserExists(generatedUsername);
            } while (isUsernameAlreadyExist);
            return OperationResult.success().addPayload(generatedUsername);
        } catch (CannotCreateTransactionException e) {
            return OperationResult.databaseDown();
        } catch (Exception e) {
            log.error("{} Exception on checking username on existence.", TAG);
            log.debug("", e);
            return OperationResult.generalFail();
        }
    }

    public OperationResult generateFromEmail(final String emailAddress) {
        String[] parts = emailAddress.split(Axe.C.AT);
        if (parts.length < 2) {
            return OperationResult.malformedInput().withMessage(String.format("%s is not valid email", emailAddress));
        }
        String[] usernameParts = parts[0].split("\\" + Axe.C.PLUS);
        if (usernameParts.length < 1) {
            return OperationResult.malformedInput().withMessage("Something is wrong with provided email");
        }
        String nameFromEmail = usernameParts[0];
        OperationResult nameValidationResult = UsernameValidator.isValid(nameFromEmail);
        if (nameValidationResult.notOk()) {
            return generateRandom();
        }
        boolean isUsernameAlreadyExist = userService.isUserExists(nameFromEmail);
        if (isUsernameAlreadyExist) {
            String generatedName;
            for (int i=1; i <= MAX_ROUNDS; i++) {
                generatedName = nameFromEmail + i;
                nameValidationResult = UsernameValidator.isValid(generatedName);
                if (nameValidationResult.notOk()) {
                    return generateRandom();
                }
                isUsernameAlreadyExist = userService.isUserExists(generatedName);
                if (!isUsernameAlreadyExist) {
                    return OperationResult.success().addPayload(generatedName);
                }
            }
            return generateRandom();
        } else {
            return OperationResult.success().addPayload(nameFromEmail);
        }
    }

    private String generateNew() {
        return USER_PREFIX + RandomStringUtils.randomNumeric(USERNAME_RANDOM_PART_LEN);
    }
}
